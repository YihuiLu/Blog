<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><id>/Blog/</id><title>一灰的技术博客</title><updated>2020-09-28T06:09:50.605361+08:06</updated><author><name>一灰</name><email>isRichard.Lu@gmail.com</email></author><link href="/Blog/" rel="alternate"/><generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator><logo>https://cdn.jsdelivr.net/gh/YihuiLu/Blog@gh-pages/logo.png</logo><subtitle>花径不曾缘客扫，蓬门今始为君开</subtitle><entry><id>/Blog/archives/CSRF/</id><title>Flask的跨域请求问题（CSRF）</title><updated>2020-09-28T06:09:50.605776+00:00</updated><author><name>一灰</name><email>isRichard.Lu@gmail.com</email><uri>https://github.com/YihuiLu</uri></author><content>&lt;p&gt;#前言：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;跨域问题&lt;/strong&gt;  &lt;em&gt;“Cross-Origin Resource Sharing (CORS)”&lt;/em&gt; 的&lt;strong&gt;本质&lt;/strong&gt;是 浏览器禁止从一个源加载的脚本与另一个源进行交互，即 --- *&lt;strong&gt;浏览器的同源策略（Same-origin policy）&lt;/strong&gt;&lt;em&gt;他的&lt;/em&gt;&lt;em&gt;定义&lt;/em&gt;*是：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;The &lt;strong&gt;same-origin policy&lt;/strong&gt; is a critical security mechanism that restricts how a document or script loaded from one &lt;a href="https://developer.mozilla.org/en-US/docs/Glossary/origin" title="origin: Web content's origin is defined by the scheme (protocol), host (domain), and port of the URL used to access it. Two objects have the same origin only when the scheme, host, and port all match."&gt;origin&lt;/a&gt; can interact with a resource from another origin. It helps to isolate potentially malicious documents, reducing possible attack vectors.&lt;/p&gt;&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。&lt;/p&gt;&lt;p&gt;#经过：
   最近使用flask编写了一个前后端分离的web项目，前端对接时使用$.ajax，并且出现了如下问题：
&lt;figure style="flex: 202.28571428571428" &gt;&lt;img width="708" height="175" src="https://upload-images.jianshu.io/upload_images/9076474-05f27195b6a09b7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;
&lt;figure style="flex: 319.87179487179486" &gt;&lt;img width="499" height="78" src="https://upload-images.jianshu.io/upload_images/9076474-174e3c5b1e0dcdd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;&lt;p&gt;#解决思路：
我们已经知道出现跨域问题的核心原因是浏览器的同源策略，所以解决问题的思路有两个：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;从浏览器端解决&lt;/li&gt;
&lt;li&gt;从服务器端解决&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这次先谈如何从服务端解决，但是想要解决这个问题我们就需要搞明白到底什么是同源：&lt;/p&gt;&lt;p&gt;#####同源的定义：&lt;/p&gt;&lt;p&gt;如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的&lt;strong&gt;源&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;下表给出了相对&lt;code&gt;http://store.company.com/dir/page.html&lt;/code&gt;同源检测的示例:&lt;/p&gt;&lt;p&gt;| URL | 结果 | 原因 |
| &lt;code&gt;http://store.company.com/dir2/other.html&lt;/code&gt; | 成功 |  |
| &lt;code&gt;http://store.company.com/dir/inner/another.html&lt;/code&gt; | 成功 |  |
| &lt;code&gt;https://store.company.com/secure.html&lt;/code&gt; | 失败 | 不同协议 ( https和http ) |
| &lt;code&gt;http://store.company.com:81/dir/etc.html&lt;/code&gt; | 失败 | 不同端口 ( 81和80) |
| &lt;code&gt;http://news.company.com/dir/other.html&lt;/code&gt; | 失败 | 不同域名 ( news和store ) |&lt;/p&gt;&lt;p&gt;另请参见&lt;a href="https://developer.mozilla.org/en-US/docs/Same-origin_policy_for_file:_URIs"&gt;文件的源定义: URLs&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;#解决方案&lt;/p&gt;&lt;p&gt;我们可以使用CORS的方式解决这个问题“Cross-Origin Resource Sharing (CORS)”&lt;/p&gt;&lt;p&gt;&lt;strong&gt;什么是CORS？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;Cross-Origin Resource Sharing (&lt;a href="https://developer.mozilla.org/en-US/docs/Glossary/CORS" title="CORS: CORS (Cross-Origin Resource Sharing) is a system, consisting of transmitting HTTP headers, that determines whether browsers block frontend JavaScript code from accessing responses for cross-origin requests."&gt;CORS&lt;/a&gt;) is a mechanism that uses additional &lt;a href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP" title="HTTP: The HyperText Transfer Protocol (HTTP) is the underlying network protocol that enables transfer of hypermedia documents on the Web, typically between a browser and a server so that humans can read them. The current version of the HTTP specification is called HTTP/2."&gt;HTTP&lt;/a&gt; headers to tell a browser to let a web application running at one origin (domain) have permission to access selected resources from a server at a different origin. A web application makes a &lt;strong&gt;cross-origin HTTP request&lt;/strong&gt; when it requests a resource that has a different origin (domain, protocol, and port) than its own origin.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;跨源资源共享（&lt;a href="https://developer.mozilla.org/en-US/docs/Glossary/CORS" title="CORS：CORS（跨源资源共享）是一个系统，由传输HTTP标头组成，用于确定浏览器是否阻止前端JavaScript代码访问跨源请求的响应。"&gt;CORS&lt;/a&gt;）是一种机制，它使用其他&lt;a href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP" title="HTTP：超文本传输​​协议（HTTP）是底层网络协议，它允许在Web上传输超媒体文档，通常在浏览器和服务器之间传输，以便人们可以读取它们。 HTTP规范的当前版本称为HTTP / 2。"&gt;HTTP&lt;/a&gt;标头告诉浏览器让在一个源（域）上运行的Web应用程序有权从不同来源的服务器访问所选资源。Web应用程序在请求具有与其自己的源不同的源（域，协议和端口）的资源时，会发出&lt;strong&gt;跨源HTTP请求&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;一个跨域请求的例子：JavaScript的Web应用程序代码所服务的前端&lt;code&gt;http://domain-a.com&lt;/code&gt;应用&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" title="使用XMLHttpRequest（XHR）对象与服务器进行交互。 您可以从URL检索数据，而无需进行整页刷新。 这使网页只更新页面的一部分，而不会中断用户正在做的事情。"&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;做出了要求&lt;code&gt;http://api.domain-b.com/data.json&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;出于安全原因，浏览器会限制从脚本中发起的跨源HTTP请求。例如，&lt;code&gt;XMLHttpRequest&lt;/code&gt;与&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"&gt;提取API&lt;/a&gt;遵循&lt;a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy"&gt;同源策略&lt;/a&gt;。这意味着使用这些API的Web应用程序只能从加载应用程序的同一源请求HTTP资源，除非来自其他来源的响应包含正确的CORS标头。&lt;/p&gt;&lt;figure style="flex: 71.9284603421462" &gt;&lt;img width="925" height="643" src="http://upload-images.jianshu.io/upload_images/9076474-4b5467b967b622e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /&gt;&lt;figcaption&gt;image&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;CORS机制支持浏览器和Web服务器之间的安全跨源请求和数据传输。现代浏览器在API容器（如&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"&gt;Fetch&lt;/a&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;或&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"&gt;Fetch）中&lt;/a&gt;使用CORS 来帮助降低跨源HTTP请求的风险。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;如何在分flask中使用？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from flask_cors import *

app = Flask(__name__)
CORS(app, supports_credentials=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;亦或者你可以使用装饰器的方式为指定的视图函数进行配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@app.route(&amp;quot;/&amp;quot;)
@cross_origin()
def helloWorld():
  return &amp;quot;Hello, cross-origin-world!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;flask中有随时可用的flask_cors 库，你可以直接调用他&lt;/p&gt;&lt;p&gt;以下是Flask-CORS 的官方文档链接&lt;/p&gt;&lt;p&gt;&lt;a href="http://flask-cors.readthedocs.io/en/latest/"&gt;&lt;a href="http://flask-cors.readthedocs.io/en/latest/"&gt;http://flask-cors.readthedocs.io/en/latest/&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;#原理？&lt;/p&gt;&lt;blockquote&gt;
&lt;h2&gt;Functional overview&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Functional_overview"&gt;Section&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The Cross-Origin Resource Sharing standard works by adding new &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers"&gt;HTTP headers&lt;/a&gt; that allow servers to describe the set of origins that are permitted to read that information using a web browser. Additionally, for HTTP request methods that can cause side-effects on server's data (in particular, for HTTP methods other than &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET" title="The HTTP GET method requests a representation of the specified resource. Requests using GET should only retrieve data."&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, or for &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" title="The HTTP POST method sends data to the server. The type of the body of the request is indicated by the Content-Type header."&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; usage with certain &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types"&gt;MIME types&lt;/a&gt;), the specification mandates that browsers &amp;quot;preflight&amp;quot; the request, soliciting supported methods from the server with an HTTP &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS" title="The HTTP OPTIONS method is used to describe the communication options for the target resource. The client can specify a URL for the OPTIONS method, or an asterisk (*) to refer to the entire server."&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request method, and then, upon &amp;quot;approval&amp;quot; from the server, sending the actual request with the actual HTTP request method. Servers can also notify clients whether &amp;quot;credentials&amp;quot; (including &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies"&gt;Cookies&lt;/a&gt; and HTTP Authentication data) should be sent with requests.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;CORS failures result in errors, but for security reasons, specifics about what went wrong &lt;em&gt;are not available to JavaScript code&lt;/em&gt;. All the code knows is that an error occurred. The only way to determine what specifically went wrong is to look at the browser's console for details.
Subsequent sections discuss scenarios, as well as provide a breakdown of the HTTP headers used.
跨源资源共享标准的工作原理是添加新的&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers"&gt;HTTP标头&lt;/a&gt;，允许服务器描述允许使用Web浏览器读取该信息的起源集。此外，对于可能对服务器数据产生副作用的HTTP请求方法（特别是对于除某些&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types"&gt;MIME类型&lt;/a&gt;以外的HTTP方法&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET" title="HTTP GET方法请求指定资源的表示。 使用GET的请求应该只检索数据。"&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;或用于&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" title="HTTP POST方法将数据发送到服务器。 请求正文的类型由Content-Type标头指示。"&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;某些&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types"&gt;MIME类型&lt;/a&gt;），规范要求浏览器“预检”请求，从而请求支持的方法。服务器使用HTTP &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS" title="HTTP OPTIONS方法用于描述目标资源的通信选项。 客户端可以指定OPTIONS方法的URL，也可以指定星号（*）来引用整个服务器。"&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt;请求方法，然后，在服务器“批准”后，使用实际的HTTP请求方法发送实际请求。服务器还可以通知客户端是否“凭据”（包括&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies"&gt;Cookie）&lt;/a&gt; 和HTTP认证数据）应该与请求一起发送。&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;CORS失败会导致错误，但出于安全原因，&lt;em&gt;JavaScript代码无法使用&lt;/em&gt;有关错误&lt;em&gt;的详细信息&lt;/em&gt;。所有代码都知道发生了错误。确定具体问题的唯一方法是查看浏览器的控制台以获取详细信息。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;仓促整理，不喜勿喷&lt;/p&gt;</content><link href="/Blog/archives/CSRF/" rel="alternate"/><published>2019-07-27T01:05:00+08:06</published></entry><entry><id>/Blog/archives/SpeechRecognition/</id><title>MacOS 下 Pycharm运行SpeechRecognition无法录音</title><updated>2020-09-28T06:09:50.605745+00:00</updated><author><name>一灰</name><email>isRichard.Lu@gmail.com</email><uri>https://github.com/YihuiLu</uri></author><content>&lt;p&gt;关联同样环境下的其他库和服务&lt;/p&gt;&lt;p&gt;比如：摄像头&lt;/p&gt;&lt;p&gt;因为涉及到调用硬件，MacOS会请求用户授权，由于2020.3以前的Pycharm并不兼容授权功能，导致代码运行不正常&lt;/p&gt;&lt;p&gt;解决方式：&lt;/p&gt;&lt;p&gt;建议直接在终端运行代码吧，&lt;/p&gt;&lt;p&gt;或者升级Pycharm到最新&lt;/p&gt;&lt;p&gt;也可以通过其他方法让Pycharm得到授权，但太麻烦了，得不偿失&lt;/p&gt;</content><link href="/Blog/archives/SpeechRecognition/" rel="alternate"/><published>2020-07-17T11:05:00+08:06</published></entry><entry><id>/Blog/archives/redis/</id><title>DBUtils 报错 codec can't encode characters in position</title><updated>2020-09-28T06:09:50.605698+00:00</updated><author><name>一灰</name><email>isRichard.Lu@gmail.com</email><uri>https://github.com/YihuiLu</uri></author><content>&lt;p&gt;今天使用DBUtils连接池遇到以下问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;'latin-1' codec can't encode characters in position 74-75: ordinal not in range(256)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##解决方法：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;标准的连接方式相同，在初始化PooledDB时声明 charset=’utf8’&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;##代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pool = PooledDB(pymysql,

mincached=5,# 连接池里的最少连接数

                maxcached=30,#最大的空闲连接数，如果空闲连接数大于这个数，pool会关闭空闲连接

                maxshared=1000,#当连接数达到这个数，新请求的连接会分享已经分配出去的连接

                maxconnections=2000,#最大的连接数，

                blocking=True,#当连接数达到最大的连接数时，在请求连接的时候，如果这个值是True，请求连接的程序会一直等待，直到当前连接数小于最大连接数，如果这个值是False，会报错，

                host='rds93vu04hr3rn0o2d5io.mysql.rds.aliyuncs.com',

user='yd_loan_admin',

passwd='abcde123!@#',

db='yd_loan_sys',

port=3306,

charset='utf8')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##经过测试问题完美解决&lt;/p&gt;</content><link href="/Blog/archives/redis/" rel="alternate"/><published>2020-07-17T11:05:00+08:06</published></entry><entry><id>/Blog/archives/Flask/</id><title>如何快速使用Flask框架开发一个企业级Restful API服务？</title><updated>2020-09-28T06:09:50.605648+00:00</updated><author><name>一灰</name><email>isRichard.Lu@gmail.com</email><uri>https://github.com/YihuiLu</uri></author><content/><link href="/Blog/archives/Flask/" rel="alternate"/><published>2020-08-17T13:34:00+08:06</published></entry><entry><id>/Blog/archives/Celery/</id><title>Flask + Celery 实现分布式异步处理</title><updated>2020-09-28T06:09:50.605618+00:00</updated><author><name>一灰</name><email>isRichard.Lu@gmail.com</email><uri>https://github.com/YihuiLu</uri></author><content>&lt;p&gt;修改一下试试修改邮箱效果&lt;/p&gt;</content><link href="/Blog/archives/Celery/" rel="alternate"/><published>2020-09-01T13:34:00+08:06</published></entry><entry><id>/Blog/archives/java/</id><title>Linux 下安装Java 14（适用大多数Linux发行版）</title><updated>2020-09-28T06:09:50.605586+00:00</updated><author><name>一灰</name><email>isRichard.Lu@gmail.com</email><uri>https://github.com/YihuiLu</uri></author><content>&lt;h3&gt;1. 在/usr/下创建java目录&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;root@9314e39c1d8c: mkdir/usr/java
root@9314e39c1d8c: cd /usr/java
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;2. 下载Java压缩文件并解压&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;root@9314e39c1d8c: curl -O curl -O https://download.oracle.com/otn-pub/java/jdk/14.0.2+12/205943a0976c4ed48cb16f1043c5c647/jdk-14.0.2_linux-x64_bin.tar.gz?AuthParam=1599111678_3050bd9ff5d540cc544a0567b2d3e31f
root@9314e39c1d8c: tar -zxvf jdk-14.0.2_linux-x64_bin.tar.gz\?AuthParam\=1599111678_3050bd9ff5d540cc544a0567b2d3e31f
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以来这里下载自己需要的版本：
&lt;a href="https://www.oracle.com/cn/java/technologies/javase-downloads.html"&gt;&lt;a href="https://www.oracle.com/cn/java/technologies/javase-downloads.html"&gt;https://www.oracle.com/cn/java/technologies/javase-downloads.html&lt;/a&gt;&lt;/a&gt;
下载完以后自行调整安装指令&lt;/p&gt;&lt;h3&gt;3. 设置环境变量&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;root@9314e39c1d8c: vi /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在文件最后添加如下内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JAVA_HOME=/usr/java/jdk-14.0.2
JRE_HOME=/usr/java/jdk-14.0.2/jre
CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib
PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
export JAVA_HOME JRE_HOME CLASS_PATH PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;4. 更新配置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;root@9314e39c1d8c: source /etc/profile&lt;/code&gt;&lt;/p&gt;&lt;h3&gt;5. 验证&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;root@9314e39c1d8c:/usr/java# java --version
java 14.0.2 2020-07-14
Java(TM) SE Runtime Environment (build 14.0.2+12-46)
Java HotSpot(TM) 64-Bit Server VM (build 14.0.2+12-46, mixed mode, sharing)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;大功告成&lt;/h1&gt;
</content><link href="/Blog/archives/java/" rel="alternate"/><published>2020-09-03T13:34:00+08:06</published></entry><entry><id>/Blog/archives/Python/</id><title>Python 包管理工具合集</title><updated>2020-09-28T06:09:50.605554+00:00</updated><author><name>一灰</name><email>isRichard.Lu@gmail.com</email><uri>https://github.com/YihuiLu</uri></author><content/><link href="/Blog/archives/Python/" rel="alternate"/><published>2020-09-04T11:14:00+08:06</published></entry><entry><id>/Blog/archives/sqlalchemy_db/</id><title>sqlalchemy 绑定多个数据库</title><updated>2020-09-28T06:09:50.605519+00:00</updated><author><name>一灰</name><email>isRichard.Lu@gmail.com</email><uri>https://github.com/YihuiLu</uri></author><content>&lt;p&gt;#绑定多个数据库
从 0.12 开始，Flask-SQLAlchemy 可以容易地连接到多个数据库。为了实现这个功能，预配置了 SQLAlchemy 来支持多个 “binds”。&lt;/p&gt;&lt;p&gt;什么是绑定(binds)? 在 SQLAlchemy 中一个绑定(bind)是能执行 SQL 语句并且通常是一个连接或者引擎类的东东。在 Flask-SQLAlchemy 中，绑定(bind)总是背后自动为您创建好的引擎。这些引擎中的每个之后都会关联一个短键（bind key）。这个键会在模型声明时使用来把一个模型关联到一个特定引擎。&lt;/p&gt;&lt;p&gt;如果模型没有关联一个特定的引擎的话，就会使用默认的连接(SQLALCHEMY_DATABASE_URI 配置值)。&lt;/p&gt;&lt;p&gt;##示例配置
下面的配置声明了三个数据库连接。特殊的默认值和另外两个分别名为 users&lt;code&gt;（用于用户）和&lt;/code&gt;appmeta 连接到一个提供只读访问应用内部数据的 sqlite 数据库）:&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SQLALCHEMY_DATABASE_URI&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;postgres://localhost/main&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;SQLALCHEMY_BINDS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;users&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;        &lt;span class="s1"&gt;&amp;#39;mysqldb://localhost/users&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;appmeta&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;      &lt;span class="s1"&gt;&amp;#39;sqlite:////path/to/appmeta.db&amp;#39;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;##创建和删除表
create_all() 和 drop_all() 方法默认作用于所有声明的绑定(bind)，包括默认的。这个行为可以通过提供 bind 参数来定制。它可以是单个绑定(bind)名, '&lt;strong&gt;all&lt;/strong&gt;' 指向所有绑定(binds)或一个绑定(bind)名的列表。默认的绑定(bind)(SQLALCHEMY_DATABASE_URI) 名为 None:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; db.create_all()
&amp;gt;&amp;gt;&amp;gt; db.create_all(bind=['users'])
&amp;gt;&amp;gt;&amp;gt; db.create_all(bind='appmeta')
&amp;gt;&amp;gt;&amp;gt; db.drop_all(bind=None)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##引用绑定(Binds)
当您声明模型时，您可以用 &lt;strong&gt;bind_key&lt;/strong&gt; 属性指定绑定(bind):&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;User&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Model&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;__bind_key__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;users&amp;#39;&lt;/span&gt;
    &lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;primary_key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;username&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;unique&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;bind key 存储在表中的 info 字典中作为 'bind_key' 键值。了解这个很重要，因为当您想要直接创建一个表对象时，您会需要把它放在那:&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;user_favorites&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Table&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;user_favorites&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;user_id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ForeignKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;user.id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
    &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;message_id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ForeignKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;message.id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
    &lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;bind_key&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;users&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果您在模型上指定了 &lt;strong&gt;bind_key&lt;/strong&gt; ，您可以用它们准确地做您想要的。模型会自行连 接到指定的数据库连接。&lt;/p&gt;</content><link href="/Blog/archives/sqlalchemy_db/" rel="alternate"/><published>2020-09-07T10:18:00+08:06</published></entry><entry><id>/Blog/archives/Celery_jpype/</id><title>Celery+jpype 卡死，Celery+Java 卡死，Celery Task 卡死</title><updated>2020-09-28T06:09:50.605480+00:00</updated><author><name>一灰</name><email>isRichard.Lu@gmail.com</email><uri>https://github.com/YihuiLu</uri></author><content>&lt;p&gt;最近在写一个项目的时候同时使用到了&lt;code&gt;Celery&lt;/code&gt;和&lt;code&gt;jpype&lt;/code&gt;&lt;/p&gt;&lt;p&gt;但是在实际使用过程中出现了Celery Task进程卡死的情况&lt;/p&gt;&lt;p&gt;解决思路如下：&lt;/p&gt;&lt;p&gt;首先是观察到涉及到使用&lt;code&gt;jpype&lt;/code&gt;的代码在本地运行没有问题，代码片段如下：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;jpype&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;

&lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;load_trie&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;maps&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;JClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;java.util.TreeMap&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)()&lt;/span&gt;  &lt;span class="c1"&gt;# 创建 TreeMap 空间&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;maps&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;
    &lt;span class="n"&gt;rs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;JClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;com.hankcs.hanlp.collection.trie.DoubleArrayTrie&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;maps&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;rs&lt;/span&gt;

&lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过排错后发现代码停止在以下位置：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;rs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;JClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;com.hankcs.hanlp.collection.trie.DoubleArrayTrie&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;maps&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码调用了Java相关的包，于是Google到了以下内容
&lt;a href="https://github.com/jpype-project/jpype/issues/358"&gt;&lt;a href="https://github.com/jpype-project/jpype/issues/358"&gt;https://github.com/jpype-project/jpype/issues/358&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在这个issues中提到了：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;Wow that is failing in a very strange spot. When you said failed in a thread I figured it would be in the proxy code, but this is a fail on getting environment variables on startup. Are you sure that you don't have more than one JVM started? Your module doesn't do a check for isJVMStarted, but I thought that we have explicit checks to prevent a fail there so that seems unlikely. The trace also does not show a second call.
My next best guess is this is a security violation. I don't know much about celery, but it may be possible that it is trying to start the JVM from within some type of sand box. My approach would be to instrument the call to JPEnv::CreateJavaVM to record all the inputs that are being passed to JVM and see if I was sure that nothing bad got sent to the JVM call. As you can see in the trace, we haven't even made contact with the JVM, so assuming we are providing it with valid inputs the bug is likely in the JVM and not within JPype.
The last option here though it seems unlikely is the shared memory loader for the jvm has somehow failed. The only thing that we do with the JVM before this point is loading the shared library into memory. On architectures with mixed executable files (32/64) this can often go wrong leading to a bad entry point. But as you ran to the Parse locale it seems unlikely.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;

&lt;pre&gt;&lt;code&gt;C  [libjava.dylib+0xd2a7]  getMacOSXLocale+0x123
C  [libjava.dylib+0xd353]  setupMacOSXLocale+0x12
C  [libjava.dylib+0xd765]  ParseLocale+0x2e
C  [libjava.dylib+0xd4ef]  GetJavaProperties+0x183
C  [libjava.dylib+0x5cbb]  Java_java_lang_System_initProperties+0x30
j  java.lang.System.initProperties(Ljava/util/Properties;)Ljava/util/Properties;+0
j  java.lang.System.initializeSystemClass()V+13
v  ~StubRoutines::call_stub
V  [libjvm.dylib+0x2f0b3a]
V  [libjvm.dylib+0x2f0d35]
V  [libjvm.dylib+0x2f0ead]
V  [libjvm.dylib+0x57313b]
V  [libjvm.dylib+0x3271b2]
C  [_jpype.cpython-36m-darwin.so+0x242cb]  _ZN5JPEnv12CreateJavaVMEPv+0x3b
The specific failure point is

 // Get the entry points in the shared library
 loadEntryPoints(vmPath);  &amp;lt;== Could load invalid pointers

 JavaVMInitArgs jniArgs;
 jniArgs.options = NULL;

 // prepare this ...
 jniArgs.version = USE_JNI_VERSION;
 jniArgs.ignoreUnrecognized = ignoreUnrecognized;

 jniArgs.nOptions = (jint)args.size();
 jniArgs.options = (JavaVMOption*)malloc(sizeof(JavaVMOption)*jniArgs.nOptions);
 memset(jniArgs.options, 0, sizeof(JavaVMOption)*jniArgs.nOptions);
 for (int i = 0; i &amp;lt; jniArgs.nOptions; i++)
 {
   jniArgs.options[i].optionString = (char*)args[i].c_str();  &amp;lt;== All options should be valid
 }
 JPEnv::CreateJavaVM((void*)&amp;amp;jniArgs);  &amp;lt;== Everything in the structure should be valid at this point
 free(jniArgs.options);
The only trace I could find that was similar is

https://bugs.openjdk.java.net/secure/attachment/72587/hs_err_pid55488.log
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;再加上这个issues中的其他信息，猜测是在&lt;code&gt;celery&lt;/code&gt;的&lt;code&gt;worker&lt;/code&gt;中因为某种环境的影响导致&lt;code&gt;Java&lt;/code&gt;无法正常运行，并与&lt;code&gt;JVM&lt;/code&gt;有关&lt;/p&gt;&lt;p&gt;并且最后他们提到&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;Starting after the fork is by far the safest approach.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;然后这个问题还关闭了，这就郁闷了，但请教同事建议我看了这个：
&lt;a href="https://stackoverflow.com/questions/12003221/celery-task-schedule-ensuring-a-task-is-only-executed-one-at-a-time"&gt;&lt;a href="https://stackoverflow.com/questions/12003221/celery-task-schedule-ensuring-a-task-is-only-executed-one-at-a-time"&gt;https://stackoverflow.com/questions/12003221/celery-task-schedule-ensuring-a-task-is-only-executed-one-at-a-time&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;最后找到了：&lt;a href="https://docs.celeryproject.org/en/stable/reference/celery.bin.worker.html#cmdoption-celery-worker-p"&gt;&lt;a href="https://docs.celeryproject.org/en/stable/reference/celery.bin.worker.html#cmdoption-celery-worker-p"&gt;https://docs.celeryproject.org/en/stable/reference/celery.bin.worker.html#cmdoption-celery-worker-p&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;猜测跟worker运行时的线程约束有关，于是乎测试：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-P, --pool
Pool implementation:

prefork (default), eventlet, gevent, threads or solo.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##然后就顺利的成功了&lt;/p&gt;&lt;p&gt;最后的worker启动命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;celery -A celery_app.worker:celery worker -c 4 -l info -P solo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重点在于&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-P solo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令指定了每个worker只能用单线程模式执行，这样就不会导致JVM出现不可预知的问题&lt;/p&gt;&lt;p&gt;经过测试在指定 &lt;code&gt;-P solo&lt;/code&gt; 的同时可以指定 &lt;code&gt;-c&lt;/code&gt;&lt;/p&gt;&lt;p&gt;仓促记录，日后修改&lt;/p&gt;</content><link href="/Blog/archives/Celery_jpype/" rel="alternate"/><published>2020-09-08T16:58:00+08:06</published></entry><entry><id>/Blog/archives/Go_1/</id><title>Go语言入门心得</title><updated>2020-09-28T06:09:50.605416+00:00</updated><author><name>一灰</name><email>isRichard.Lu@gmail.com</email><uri>https://github.com/YihuiLu</uri></author><content/><link href="/Blog/archives/Go_1/" rel="alternate"/><published>2020-09-28T16:58:00+08:06</published></entry></feed>