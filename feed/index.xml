<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>一灰的技术博客</title><link>/Blog/</link><description>花径不曾缘客扫，蓬门今始为君开</description><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://cdn.jsdelivr.net/gh/YihuiLu/Blog@gh-pages/logo.png</url><title>一灰的技术博客</title><link>/Blog/</link></image><language>zh-CN</language><lastBuildDate>Mon, 07 Sep 2020 02:22:04 +0806</lastBuildDate><pubDate>Mon, 07 Sep 2020 02:22:04 +0806</pubDate><item><title>MySQL &amp; SQLit忽略外键约束删除数据</title><link>/Blog/archives/FOREIGN_KEY_CHECKS/</link><description>&lt;p&gt;今天在删除表数据时遇到一个问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ERROR 1701 (42000): Cannot truncate a table referenced
in a foreign key constraint
(`diandian_loan`.`auth_group_permissions`, CONSTRAINT 
`auth_group_permissi_permission_id_84c5c92e_fk_auth_p
ermission_id` FOREIGN KEY (`permission_id`) REFERENCES 
`diandian_loan`.`auth_permissio)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;意思是由于有&lt;strong&gt;主外键约束&lt;/strong&gt;，所以不能删除表数据。&lt;/p&gt;&lt;p&gt;即使当时已经将父表数据清空还是不行。&lt;/p&gt;&lt;h3&gt;解决办法：&lt;/h3&gt;
&lt;p&gt;先取消主外键关系验证：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;FOREIGN_KEY_CHECKS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后删除需要删除的数据&lt;/p&gt;&lt;p&gt;最后恢复：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;FOREIGN_KEY_CHECKS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SQLit略有不同&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;PRAGMA&lt;/span&gt; &lt;span class="n"&gt;foreign_keys&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;PRAGMA&lt;/span&gt; &lt;span class="n"&gt;foreign_keys&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;完美解决&lt;/em&gt;&lt;/p&gt;</description><author>isRichard.Lu@gmail.com (一灰)</author><guid isPermaLink="true">/Blog/archives/FOREIGN_KEY_CHECKS/</guid><pubDate>Fri, 22 Feb 2019 09:05:00 +0806</pubDate></item><item><title>redis.Redis与redis.StrictRedis区别</title><link>/Blog/archives/redis/</link><description>&lt;p&gt;redis-py提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令（比如，SET命令对应与StrictRedis.set方法）。Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py。 简单说，官方推荐使用StrictRedis方法。&lt;/p&gt;&lt;p&gt;不推荐Redis类，原因是他和咱们在redis-cli操作有些不一样，主要不一样是下面这三个方面。&lt;/p&gt;&lt;p&gt;·LREM：参数 ‘num’ 和 ‘value’ 的顺序交换了一下，cli是 lrem queueName 0 ‘string’ 。 这里的0时所有的意思。 但是Redis这个类，把控制和string调换了。&lt;/p&gt;&lt;p&gt;·ZADD：实现时 score 和 value 的顺序不小心弄反了，后来有人用了，就这样了&lt;/p&gt;&lt;p&gt;·SETEX: time 和 value 的顺序反了&lt;/p&gt;&lt;p&gt;.Pool: 连接池&lt;/p&gt;&lt;p&gt;Redis的连接池的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pool = redis.ConnectionPool(host=‘localhost‘, port=6379, db=0)

r = redis.Redis(connection_pool=pool)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;StrictRedis的连接池的实现方式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;In [4]: pool = redis.ConnectionPool(host=‘127.0.0.1‘, port=6379)

In [5]: r = redis.StrictRedis(connection_pool=pool)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;官方的创建redis的时候，都可以添加什么参数。&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;class redis.StrictRedis(host=‘localhost‘, port=6379, db=0, password=None, socket_timeout=None, connection_pool=None, charset=‘utf-8‘, errors=‘strict‘, decode_responses=False, unix_socket_path=None)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Implementation of the Redis protocol.
This abstract class provides a Python interface to all Redis commands and an implementation of the Redis protocol.
Connection and Pipeline derive from this, implementing how the commands are sent and received to the Redis server&lt;/p&gt;&lt;p&gt;redis的对于有些编码入库的问题，redis的连接附加的参数里面，默认编码是utf-8，但是如果你非要用GBK那就需要指明你的chardet和decode_responses为True 。&lt;/p&gt;&lt;p&gt;原文地址(还是我的博客): &lt;a href="https://www.yifeilu.cn/index.php/archives/32/"&gt;&lt;a href="https://www.yifeilu.cn/index.php/archives/32/"&gt;https://www.yifeilu.cn/index.php/archives/32/&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;</description><author>isRichard.Lu@gmail.com (一灰)</author><guid isPermaLink="true">/Blog/archives/redis/</guid><pubDate>Wed, 17 Jul 2019 20:34:00 +0806</pubDate></item><item><title>Flask的跨域请求问题（CSRF）</title><link>/Blog/archives/CSRF/</link><description>&lt;p&gt;#前言：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;跨域问题&lt;/strong&gt;  &lt;em&gt;“Cross-Origin Resource Sharing (CORS)”&lt;/em&gt; 的&lt;strong&gt;本质&lt;/strong&gt;是 浏览器禁止从一个源加载的脚本与另一个源进行交互，即 --- *&lt;strong&gt;浏览器的同源策略（Same-origin policy）&lt;/strong&gt;&lt;em&gt;他的&lt;/em&gt;&lt;em&gt;定义&lt;/em&gt;*是：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;The &lt;strong&gt;same-origin policy&lt;/strong&gt; is a critical security mechanism that restricts how a document or script loaded from one &lt;a href="https://developer.mozilla.org/en-US/docs/Glossary/origin" title="origin: Web content's origin is defined by the scheme (protocol), host (domain), and port of the URL used to access it. Two objects have the same origin only when the scheme, host, and port all match."&gt;origin&lt;/a&gt; can interact with a resource from another origin. It helps to isolate potentially malicious documents, reducing possible attack vectors.&lt;/p&gt;&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。&lt;/p&gt;&lt;p&gt;#经过：
   最近使用flask编写了一个前后端分离的web项目，前端对接时使用$.ajax，并且出现了如下问题：
&lt;figure style="flex: 202.28571428571428" &gt;&lt;img width="708" height="175" src="https://upload-images.jianshu.io/upload_images/9076474-05f27195b6a09b7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;
&lt;figure style="flex: 319.87179487179486" &gt;&lt;img width="499" height="78" src="https://upload-images.jianshu.io/upload_images/9076474-174e3c5b1e0dcdd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;&lt;p&gt;#解决思路：
我们已经知道出现跨域问题的核心原因是浏览器的同源策略，所以解决问题的思路有两个：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;从浏览器端解决&lt;/li&gt;
&lt;li&gt;从服务器端解决&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这次先谈如何从服务端解决，但是想要解决这个问题我们就需要搞明白到底什么是同源：&lt;/p&gt;&lt;p&gt;#####同源的定义：&lt;/p&gt;&lt;p&gt;如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的&lt;strong&gt;源&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;下表给出了相对&lt;code&gt;http://store.company.com/dir/page.html&lt;/code&gt;同源检测的示例:&lt;/p&gt;&lt;p&gt;| URL | 结果 | 原因 |
| &lt;code&gt;http://store.company.com/dir2/other.html&lt;/code&gt; | 成功 |  |
| &lt;code&gt;http://store.company.com/dir/inner/another.html&lt;/code&gt; | 成功 |  |
| &lt;code&gt;https://store.company.com/secure.html&lt;/code&gt; | 失败 | 不同协议 ( https和http ) |
| &lt;code&gt;http://store.company.com:81/dir/etc.html&lt;/code&gt; | 失败 | 不同端口 ( 81和80) |
| &lt;code&gt;http://news.company.com/dir/other.html&lt;/code&gt; | 失败 | 不同域名 ( news和store ) |&lt;/p&gt;&lt;p&gt;另请参见&lt;a href="https://developer.mozilla.org/en-US/docs/Same-origin_policy_for_file:_URIs"&gt;文件的源定义: URLs&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;#解决方案&lt;/p&gt;&lt;p&gt;我们可以使用CORS的方式解决这个问题“Cross-Origin Resource Sharing (CORS)”&lt;/p&gt;&lt;p&gt;&lt;strong&gt;什么是CORS？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;Cross-Origin Resource Sharing (&lt;a href="https://developer.mozilla.org/en-US/docs/Glossary/CORS" title="CORS: CORS (Cross-Origin Resource Sharing) is a system, consisting of transmitting HTTP headers, that determines whether browsers block frontend JavaScript code from accessing responses for cross-origin requests."&gt;CORS&lt;/a&gt;) is a mechanism that uses additional &lt;a href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP" title="HTTP: The HyperText Transfer Protocol (HTTP) is the underlying network protocol that enables transfer of hypermedia documents on the Web, typically between a browser and a server so that humans can read them. The current version of the HTTP specification is called HTTP/2."&gt;HTTP&lt;/a&gt; headers to tell a browser to let a web application running at one origin (domain) have permission to access selected resources from a server at a different origin. A web application makes a &lt;strong&gt;cross-origin HTTP request&lt;/strong&gt; when it requests a resource that has a different origin (domain, protocol, and port) than its own origin.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;跨源资源共享（&lt;a href="https://developer.mozilla.org/en-US/docs/Glossary/CORS" title="CORS：CORS（跨源资源共享）是一个系统，由传输HTTP标头组成，用于确定浏览器是否阻止前端JavaScript代码访问跨源请求的响应。"&gt;CORS&lt;/a&gt;）是一种机制，它使用其他&lt;a href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP" title="HTTP：超文本传输​​协议（HTTP）是底层网络协议，它允许在Web上传输超媒体文档，通常在浏览器和服务器之间传输，以便人们可以读取它们。 HTTP规范的当前版本称为HTTP / 2。"&gt;HTTP&lt;/a&gt;标头告诉浏览器让在一个源（域）上运行的Web应用程序有权从不同来源的服务器访问所选资源。Web应用程序在请求具有与其自己的源不同的源（域，协议和端口）的资源时，会发出&lt;strong&gt;跨源HTTP请求&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;一个跨域请求的例子：JavaScript的Web应用程序代码所服务的前端&lt;code&gt;http://domain-a.com&lt;/code&gt;应用&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" title="使用XMLHttpRequest（XHR）对象与服务器进行交互。 您可以从URL检索数据，而无需进行整页刷新。 这使网页只更新页面的一部分，而不会中断用户正在做的事情。"&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;做出了要求&lt;code&gt;http://api.domain-b.com/data.json&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;出于安全原因，浏览器会限制从脚本中发起的跨源HTTP请求。例如，&lt;code&gt;XMLHttpRequest&lt;/code&gt;与&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"&gt;提取API&lt;/a&gt;遵循&lt;a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy"&gt;同源策略&lt;/a&gt;。这意味着使用这些API的Web应用程序只能从加载应用程序的同一源请求HTTP资源，除非来自其他来源的响应包含正确的CORS标头。&lt;/p&gt;&lt;figure style="flex: 71.9284603421462" &gt;&lt;img width="925" height="643" src="http://upload-images.jianshu.io/upload_images/9076474-4b5467b967b622e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /&gt;&lt;figcaption&gt;image&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;CORS机制支持浏览器和Web服务器之间的安全跨源请求和数据传输。现代浏览器在API容器（如&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"&gt;Fetch&lt;/a&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;或&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"&gt;Fetch）中&lt;/a&gt;使用CORS 来帮助降低跨源HTTP请求的风险。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;如何在分flask中使用？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from flask_cors import *

app = Flask(__name__)
CORS(app, supports_credentials=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;亦或者你可以使用装饰器的方式为指定的视图函数进行配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@app.route(&amp;quot;/&amp;quot;)
@cross_origin()
def helloWorld():
  return &amp;quot;Hello, cross-origin-world!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;flask中有随时可用的flask_cors 库，你可以直接调用他&lt;/p&gt;&lt;p&gt;以下是Flask-CORS 的官方文档链接&lt;/p&gt;&lt;p&gt;&lt;a href="http://flask-cors.readthedocs.io/en/latest/"&gt;&lt;a href="http://flask-cors.readthedocs.io/en/latest/"&gt;http://flask-cors.readthedocs.io/en/latest/&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;#原理？&lt;/p&gt;&lt;blockquote&gt;
&lt;h2&gt;Functional overview&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Functional_overview"&gt;Section&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The Cross-Origin Resource Sharing standard works by adding new &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers"&gt;HTTP headers&lt;/a&gt; that allow servers to describe the set of origins that are permitted to read that information using a web browser. Additionally, for HTTP request methods that can cause side-effects on server's data (in particular, for HTTP methods other than &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET" title="The HTTP GET method requests a representation of the specified resource. Requests using GET should only retrieve data."&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, or for &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" title="The HTTP POST method sends data to the server. The type of the body of the request is indicated by the Content-Type header."&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; usage with certain &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types"&gt;MIME types&lt;/a&gt;), the specification mandates that browsers &amp;quot;preflight&amp;quot; the request, soliciting supported methods from the server with an HTTP &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS" title="The HTTP OPTIONS method is used to describe the communication options for the target resource. The client can specify a URL for the OPTIONS method, or an asterisk (*) to refer to the entire server."&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request method, and then, upon &amp;quot;approval&amp;quot; from the server, sending the actual request with the actual HTTP request method. Servers can also notify clients whether &amp;quot;credentials&amp;quot; (including &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies"&gt;Cookies&lt;/a&gt; and HTTP Authentication data) should be sent with requests.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;CORS failures result in errors, but for security reasons, specifics about what went wrong &lt;em&gt;are not available to JavaScript code&lt;/em&gt;. All the code knows is that an error occurred. The only way to determine what specifically went wrong is to look at the browser's console for details.
Subsequent sections discuss scenarios, as well as provide a breakdown of the HTTP headers used.
跨源资源共享标准的工作原理是添加新的&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers"&gt;HTTP标头&lt;/a&gt;，允许服务器描述允许使用Web浏览器读取该信息的起源集。此外，对于可能对服务器数据产生副作用的HTTP请求方法（特别是对于除某些&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types"&gt;MIME类型&lt;/a&gt;以外的HTTP方法&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET" title="HTTP GET方法请求指定资源的表示。 使用GET的请求应该只检索数据。"&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;或用于&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" title="HTTP POST方法将数据发送到服务器。 请求正文的类型由Content-Type标头指示。"&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;某些&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types"&gt;MIME类型&lt;/a&gt;），规范要求浏览器“预检”请求，从而请求支持的方法。服务器使用HTTP &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS" title="HTTP OPTIONS方法用于描述目标资源的通信选项。 客户端可以指定OPTIONS方法的URL，也可以指定星号（*）来引用整个服务器。"&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt;请求方法，然后，在服务器“批准”后，使用实际的HTTP请求方法发送实际请求。服务器还可以通知客户端是否“凭据”（包括&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies"&gt;Cookie）&lt;/a&gt; 和HTTP认证数据）应该与请求一起发送。&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;CORS失败会导致错误，但出于安全原因，&lt;em&gt;JavaScript代码无法使用&lt;/em&gt;有关错误&lt;em&gt;的详细信息&lt;/em&gt;。所有代码都知道发生了错误。确定具体问题的唯一方法是查看浏览器的控制台以获取详细信息。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;仓促整理，不喜勿喷&lt;/p&gt;</description><author>isRichard.Lu@gmail.com (一灰)</author><guid isPermaLink="true">/Blog/archives/CSRF/</guid><pubDate>Sat, 27 Jul 2019 01:05:00 +0806</pubDate></item><item><title>DBUtils 报错 codec can't encode characters in position</title><link>/Blog/archives/redis/</link><description>&lt;p&gt;今天使用DBUtils连接池遇到以下问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;'latin-1' codec can't encode characters in position 74-75: ordinal not in range(256)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##解决方法：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;标准的连接方式相同，在初始化PooledDB时声明 charset=’utf8’&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;##代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pool = PooledDB(pymysql,

mincached=5,# 连接池里的最少连接数

                maxcached=30,#最大的空闲连接数，如果空闲连接数大于这个数，pool会关闭空闲连接

                maxshared=1000,#当连接数达到这个数，新请求的连接会分享已经分配出去的连接

                maxconnections=2000,#最大的连接数，

                blocking=True,#当连接数达到最大的连接数时，在请求连接的时候，如果这个值是True，请求连接的程序会一直等待，直到当前连接数小于最大连接数，如果这个值是False，会报错，

                host='rds93vu04hr3rn0o2d5io.mysql.rds.aliyuncs.com',

user='yd_loan_admin',

passwd='abcde123!@#',

db='yd_loan_sys',

port=3306,

charset='utf8')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##经过测试问题完美解决&lt;/p&gt;</description><author>isRichard.Lu@gmail.com (一灰)</author><guid isPermaLink="true">/Blog/archives/redis/</guid><pubDate>Fri, 17 Jul 2020 11:05:00 +0806</pubDate></item><item><title>MacOS 下 Pycharm运行SpeechRecognition无法录音</title><link>/Blog/archives/SpeechRecognition/</link><description>&lt;p&gt;关联同样环境下的其他库和服务&lt;/p&gt;&lt;p&gt;比如：摄像头&lt;/p&gt;&lt;p&gt;因为涉及到调用硬件，MacOS会请求用户授权，由于2020.3以前的Pycharm并不兼容授权功能，导致代码运行不正常&lt;/p&gt;&lt;p&gt;解决方式：&lt;/p&gt;&lt;p&gt;建议直接在终端运行代码吧，&lt;/p&gt;&lt;p&gt;或者升级Pycharm到最新&lt;/p&gt;&lt;p&gt;也可以通过其他方法让Pycharm得到授权，但太麻烦了，得不偿失&lt;/p&gt;</description><author>isRichard.Lu@gmail.com (一灰)</author><guid isPermaLink="true">/Blog/archives/SpeechRecognition/</guid><pubDate>Fri, 17 Jul 2020 11:05:00 +0806</pubDate></item><item><title>如何快速使用Flask框架开发一个企业级Restful API服务？</title><link>/Blog/archives/Flask/</link><description></description><author>isRichard.Lu@gmail.com (一灰)</author><guid isPermaLink="true">/Blog/archives/Flask/</guid><pubDate>Mon, 17 Aug 2020 13:34:00 +0806</pubDate></item><item><title>Flask + Celery 实现分布式异步处理</title><link>/Blog/archives/Celery/</link><description></description><author>isRichard.Lu@gmail.com (一灰)</author><guid isPermaLink="true">/Blog/archives/Celery/</guid><pubDate>Tue, 01 Sep 2020 13:34:00 +0806</pubDate></item><item><title>Linux 下安装Java 14（适用大多数Linux发行版）</title><link>/Blog/archives/java/</link><description>&lt;p&gt;###1. 在/usr/下创建java目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@9314e39c1d8c: mkdir/usr/java
root@9314e39c1d8c: cd /usr/java
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###2. 下载Java压缩文件并解压&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@9314e39c1d8c: curl -O curl -O https://download.oracle.com/otn-pub/java/jdk/14.0.2+12/205943a0976c4ed48cb16f1043c5c647/jdk-14.0.2_linux-x64_bin.tar.gz?AuthParam=1599111678_3050bd9ff5d540cc544a0567b2d3e31f
root@9314e39c1d8c: tar -zxvf jdk-14.0.2_linux-x64_bin.tar.gz\?AuthParam\=1599111678_3050bd9ff5d540cc544a0567b2d3e31f
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以来这里下载自己需要的版本：
&lt;a href="https://www.oracle.com/cn/java/technologies/javase-downloads.html"&gt;&lt;a href="https://www.oracle.com/cn/java/technologies/javase-downloads.html"&gt;https://www.oracle.com/cn/java/technologies/javase-downloads.html&lt;/a&gt;&lt;/a&gt;
下载完以后自行调整安装指令&lt;/p&gt;&lt;p&gt;###3. 设置环境变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@9314e39c1d8c: vi /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在文件最后添加如下内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JAVA_HOME=/usr/java/jdk-14.0.2
JRE_HOME=/usr/java/jdk-14.0.2/jre
CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib
PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
export JAVA_HOME JRE_HOME CLASS_PATH PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###4. 更新配置&lt;/p&gt;&lt;p&gt;&lt;code&gt;root@9314e39c1d8c: source /etc/profile&lt;/code&gt;&lt;/p&gt;&lt;p&gt;###5. 验证&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@9314e39c1d8c:/usr/java# java --version
java 14.0.2 2020-07-14
Java(TM) SE Runtime Environment (build 14.0.2+12-46)
Java HotSpot(TM) 64-Bit Server VM (build 14.0.2+12-46, mixed mode, sharing)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;大功告成&lt;/h1&gt;
</description><author>isRichard.Lu@gmail.com (一灰)</author><guid isPermaLink="true">/Blog/archives/java/</guid><pubDate>Thu, 03 Sep 2020 13:34:00 +0806</pubDate></item><item><title>Python 包管理工具合集</title><link>/Blog/archives/Python/</link><description></description><author>isRichard.Lu@gmail.com (一灰)</author><guid isPermaLink="true">/Blog/archives/Python/</guid><pubDate>Fri, 04 Sep 2020 11:14:00 +0806</pubDate></item><item><title>sqlalchemy 绑定多个数据库</title><link>/Blog/archives/Celery/</link><description>&lt;p&gt;#绑定多个数据库
从 0.12 开始，Flask-SQLAlchemy 可以容易地连接到多个数据库。为了实现这个功能，预配置了 SQLAlchemy 来支持多个 “binds”。&lt;/p&gt;&lt;p&gt;什么是绑定(binds)? 在 SQLAlchemy 中一个绑定(bind)是能执行 SQL 语句并且通常是一个连接或者引擎类的东东。在 Flask-SQLAlchemy 中，绑定(bind)总是背后自动为您创建好的引擎。这些引擎中的每个之后都会关联一个短键（bind key）。这个键会在模型声明时使用来把一个模型关联到一个特定引擎。&lt;/p&gt;&lt;p&gt;如果模型没有关联一个特定的引擎的话，就会使用默认的连接(SQLALCHEMY_DATABASE_URI 配置值)。&lt;/p&gt;&lt;p&gt;##示例配置
下面的配置声明了三个数据库连接。特殊的默认值和另外两个分别名为 users&lt;code&gt;（用于用户）和&lt;/code&gt;appmeta 连接到一个提供只读访问应用内部数据的 sqlite 数据库）:&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SQLALCHEMY_DATABASE_URI&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;postgres://localhost/main&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;SQLALCHEMY_BINDS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;users&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;        &lt;span class="s1"&gt;&amp;#39;mysqldb://localhost/users&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;appmeta&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;      &lt;span class="s1"&gt;&amp;#39;sqlite:////path/to/appmeta.db&amp;#39;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;##创建和删除表
create_all() 和 drop_all() 方法默认作用于所有声明的绑定(bind)，包括默认的。这个行为可以通过提供 bind 参数来定制。它可以是单个绑定(bind)名, '&lt;strong&gt;all&lt;/strong&gt;' 指向所有绑定(binds)或一个绑定(bind)名的列表。默认的绑定(bind)(SQLALCHEMY_DATABASE_URI) 名为 None:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; db.create_all()
&amp;gt;&amp;gt;&amp;gt; db.create_all(bind=['users'])
&amp;gt;&amp;gt;&amp;gt; db.create_all(bind='appmeta')
&amp;gt;&amp;gt;&amp;gt; db.drop_all(bind=None)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##引用绑定(Binds)
当您声明模型时，您可以用 &lt;strong&gt;bind_key&lt;/strong&gt; 属性指定绑定(bind):&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;User&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Model&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;__bind_key__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;users&amp;#39;&lt;/span&gt;
    &lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;primary_key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;username&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;unique&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;bind key 存储在表中的 info 字典中作为 'bind_key' 键值。了解这个很重要，因为当您想要直接创建一个表对象时，您会需要把它放在那:&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;user_favorites&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Table&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;user_favorites&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;user_id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ForeignKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;user.id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
    &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;message_id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ForeignKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;message.id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
    &lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;bind_key&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;users&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果您在模型上指定了 &lt;strong&gt;bind_key&lt;/strong&gt; ，您可以用它们准确地做您想要的。模型会自行连 接到指定的数据库连接。&lt;/p&gt;</description><author>isRichard.Lu@gmail.com (一灰)</author><guid isPermaLink="true">/Blog/archives/Celery/</guid><pubDate>Mon, 07 Sep 2020 10:18:00 +0806</pubDate></item></channel></rss>